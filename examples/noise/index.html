<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Noise graph</title>
  <style>
    body { background: #222; color: #eee }
    svg { margin: 0; }
  </style>
  <link rel="stylesheet" href="./style.css">
  <link rel="stylesheet" href="./graph.css">
</head>

<body>

<div>
<input type="checkbox" id="fractalInput" checked>
  <label>fractal input</label>
</input>
</div>

<div>
<input type="checkbox" id="delayInput">
  <label>artificial load delay</label>
</input>
</div>

</div>
<button id="regenButton">regenerate</button>
</div>

<script type="module">

import { drawGraph } from "./graph.js";

// Simple seeded PRNG (Mulberry32)
const mulberry32 = seed => () => {
  let t = seed += 0x6D2B79F5;
  t = Math.imul(t ^ (t >>> 15), t | 1);
  t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
  return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
};

let seed = 934.414183493471

// Deterministic fractal random walk (sampling-invariant).
// Always returns 500 [x, y] points over [minX, maxX].
const generateFractalWalkData = (minX, maxX, noiseLevel = 1, seed = 1, 
  scale = 0.1,      // world units per base scale; larger => broader features
  H = 0.001,        // 0..0.5 recommended; lower => rougher, faster divergence
  fineLevels = 100, // # of fine dyadic levels (fixed for determinism)
  coarseLevels = 12 // # of coarse dyadic levels (adds long-range drift)
) => {
  const POINTS = fractalInput.checked ? 500 : 2000;
  const step = (maxX - minX) / (POINTS - 1) || 0;

  // Fast 32-bit hash -> [0,1)
  const hash01 = (k, n, s) => {
    let h = (s|0) ^ Math.imul(k|0, 374761393) ^ Math.imul(n|0, 668265263);
    h ^= h >>> 13; h = Math.imul(h, 1274126177); h ^= h >>> 16;
    return (h >>> 0) / 4294967296;
  };

  // Single coefficient ~[-1,1] (uniform is fine here)
  const coef = (k, n, s) => hash01(k, n, s) * 2 - 1;

  // Triangular "pyramid" bump Î›(u) on [0,1]: rise to 1 at 0.5, then fall
  const pyramid = (u) => 1 - Math.abs(u * 2 - 1);

  const fBmSchauder = (x, s) => {
    const u = x / scale; // dimensionless coord (global!)
    let y = 0;
    for (let k = -coarseLevels; k <= fineLevels; k++) {
      const sk = Math.pow(2, k);
      const t = u * sk;
      const n = Math.floor(t);
      const frac = t - n;        // in [0,1)
      const a = Math.pow(2, -(H + 0.5) * k); // amplitude per level
      y += a * coef(k, n, s) * pyramid(frac);
    }
    return y;
  };

  const out = [];
  for (let j = 0; j < POINTS; j++) {
    const x = minX + j * step;
    const y = fBmSchauder(x, seed | 0) * noiseLevel;
    out.push([x, y]);
  }
  return out;
};

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

const graphConfig = async () => {
  let initialLoad = true;
  const loadData = async (minX, maxX) => {
    let s = seed;
    const gen = () => generateFractalWalkData(minX, maxX, 2, s += 10);
    if (delayInput && delayInput.checked && !initialLoad) {
      await sleep(2000);
    }
    initialLoad = false;
    return [
      {label: "a", data: gen()},
      {label: "b", data: gen()},
      {label: "c", data: gen()},
      {label: "d", data: gen()}
    ];
  };
  return {
    data: await loadData(0, 1000),
    width: 600,
    height: 400,
    loadData: fractalInput.checked ? loadData : undefined
  };
};

let svg;
const run = async () => {
  console.log(`Seed: ${seed}`);
  svg = drawGraph(await graphConfig());
  document.body.insertBefore(svg, document.body.firstChild);
};
await run();

regenButton.onclick = () => {
  seed = Math.random() * 1000;
  svg.remove();
  run();
};

fractalInput.onclick = () => {
  delayInput.disabled = !fractalInput.checked;
  svg.remove();
  run();
};

delayInput.onclick = () => {
  svg.remove();
  run();
};

fractalInput.onclick();

</script>

</body
</html>
